.TH "inc/minishell.h" 3 "Minishell" \" -*- nroff -*-
.ad l
.nh
.SH NAME
inc/minishell.h
.SH SYNOPSIS
.br
.PP
\fR#include 'data_structure\&.h'\fP
.br
\fR#include 'libft\&.h'\fP
.br
\fR#include <stddef\&.h>\fP
.br
\fR#include <stdio\&.h>\fP
.br
\fR#include <stdlib\&.h>\fP
.br
\fR#include <unistd\&.h>\fP
.br
\fR#include <wait\&.h>\fP
.br

.SS "Macros"

.in +1c
.ti -1c
.RI "#define \fBPROMPT_MESSAGE_CUSTOM\fP   1"
.br
.RI "Make the prompt custom (with colors) "
.ti -1c
.RI "#define \fBFOLLOW_ZSH\fP   1"
.br
.RI "Follow certain added functionnality of ZSH to minishell\&. "
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "int \fBminishell\fP (\fBt_data\fP *data)"
.br
.RI "Minishell that handles all the shell functions\&. "
.ti -1c
.RI "int \fBis_interactive\fP (void)"
.br
.RI "Function to read the context where this function is called Verify if it's used in a tty or not,\&. "
.ti -1c
.RI "int \fBshort_minishell_no_tty\fP (\fBt_data\fP *data)"
.br
.RI "Executes the shell in a restricted area where there is no prompt Should work exactly as the minishell function\&. "
.ti -1c
.RI "char * \fBget_prompt_message\fP (\fBt_garbage\fP *garbage)"
.br
.RI "Build the prompt message If an error occurs, returns the static default prompt message\&. "
.ti -1c
.RI "int \fBsignal_init\fP (void)"
.br
.RI "Main function for initialising signals\&. "
.ti -1c
.RI "void \fBreset_signal_default\fP (void)"
.br
.RI "Function to reset signals to default\&. "
.ti -1c
.RI "void \fBignore_signal\fP (void)"
.br
.RI "Function to ignore certain signals\&. "
.ti -1c
.RI "char ** \fBinit_lexer_state\fP (\fBt_garbage\fP *garbage, \fBt_lexer_state\fP *lex_st, const char *line)"
.br
.RI "Initialize the lexer structure\&. "
.ti -1c
.RI "char ** \fBlexer\fP (\fBt_garbage\fP *garbage, const char *line)"
.br
.RI "Create tokens (small chunks) a line with the quotes and operators\&. "
.ti -1c
.RI "\fBt_command\fP * \fBtokeniser\fP (\fBt_data\fP *data, char **tokens)"
.br
.RI "Creates a \fBt_command\fP structure that contains all the tokens Fills the command with the environment\&. "
.ti -1c
.RI "char * \fBft_substr_end_gb\fP (\fBt_garbage\fP *garbage, char const *src, unsigned int start, size_t end)"
.br
.RI "Allocate memory for a string and copy the content from src\&. "
.ti -1c
.RI "int \fBis_operator_char\fP (char c)"
.br
.RI "Is |, < or > "
.ti -1c
.RI "char ** \fBparse_line\fP (\fBt_data\fP *data, char *line)"
.br
.RI "Prototype for parsing\&. "
.ti -1c
.RI "void \fBfree_array\fP (\fBt_garbage\fP *garbage, char **array)"
.br
.RI "Free array of strings\&. "
.ti -1c
.RI "void \fBfree_command\fP (\fBt_garbage\fP *garbage, \fBt_command\fP *command)"
.br
.RI "Free one \fBt_command\fP structure with all that it contains\&. "
.ti -1c
.RI "void \fBfree_commands\fP (\fBt_garbage\fP *garbage, \fBt_command\fP **command)"
.br
.RI "Free \fBt_command\fP linked list structure with all that it contains\&. "
.ti -1c
.RI "void \fBfree_files_struct\fP (\fBt_garbage\fP *garbage, \fBt_file\fP *file)"
.br
.RI "Free linked list of \fBt_file\fP structure\&. "
.ti -1c
.RI "void \fBfree_heredoc\fP (\fBt_garbage\fP *garbage, \fBt_tmp\fP *tmp)"
.br
.RI "Free heredoc structure\&. "
.ti -1c
.RI "void \fBfree_tokens\fP (\fBt_garbage\fP *garbage, \fBt_token\fP *token)"
.br
.RI "Free t_tokens linked list structure\&. "
.ti -1c
.RI "void \fBprint_list_files\fP (\fBt_command\fP *command)"
.br
.RI "Print the list of files in the command structure\&. "
.ti -1c
.RI "void \fBprint_perm_files\fP (\fBt_command\fP *command)"
.br
.RI "Print the list of permissions of files in the command structure\&. "
.ti -1c
.RI "void \fBprint_toks\fP (char **tokens)"
.br
.RI "Print tokens indexed\&. "
.ti -1c
.RI "void \fBprint_command_fd\fP (\fBt_command\fP *command)"
.br
.ti -1c
.RI "ssize_t \fBprint_command\fP (\fBt_command\fP *command)"
.br
.RI "Print the command structure with it's tokens\&. "
.ti -1c
.RI "ssize_t \fBprint_commands\fP (\fBt_command\fP **command)"
.br
.RI "Print the commands structure with it's tokens\&. "
.in -1c
.SH "Macro Definition Documentation"
.PP 
.SS "#define FOLLOW_ZSH   1"

.PP
Follow certain added functionnality of ZSH to minishell\&. 
.SS "#define PROMPT_MESSAGE_CUSTOM   1"

.PP
Make the prompt custom (with colors) looks like : "$USER$(hostname):$ colors : - user and hostname + ':'
.IP "\(bu" 2
current working directory 
.PP

.SH "Author"
.PP 
Generated automatically by Doxygen for Minishell from the source code\&.
