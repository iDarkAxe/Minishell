.TH "inc/minishell.h" 3 "Minishell" \" -*- nroff -*-
.ad l
.nh
.SH NAME
inc/minishell.h
.SH SYNOPSIS
.br
.PP
\fR#include 'libft\&.h'\fP
.br
\fR#include <signal\&.h>\fP
.br
\fR#include <stddef\&.h>\fP
.br
\fR#include <stdio\&.h>\fP
.br
\fR#include <stdlib\&.h>\fP
.br
\fR#include <unistd\&.h>\fP
.br

.SS "Data Structures"

.in +1c
.ti -1c
.RI "struct \fBs_command\fP"
.br
.ti -1c
.RI "struct \fBs_lexer_state\fP"
.br
.ti -1c
.RI "struct \fBs_token\fP"
.br
.in -1c
.SS "Macros"

.in +1c
.ti -1c
.RI "#define \fBPROMPT_MESSAGE_CUSTOM\fP   1"
.br
.ti -1c
.RI "#define \fBFOLLOW_ZSH\fP   0"
.br
.in -1c
.SS "Typedefs"

.in +1c
.ti -1c
.RI "typedef struct \fBs_command\fP \fBt_command\fP"
.br
.ti -1c
.RI "typedef struct \fBs_lexer_state\fP \fBt_lexer_state\fP"
.br
.ti -1c
.RI "typedef struct \fBs_token\fP \fBt_token\fP"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "int \fBminishell\fP (char **envp)"
.br
.RI "Minishell that handles all the shell functions\&. "
.ti -1c
.RI "int \fBread_context\fP (char **envp)"
.br
.RI "Function to read the context where this function is called Verify if it's used in a tty or not\&. "
.ti -1c
.RI "void \fBshort_minishell_no_tty\fP (char **envp)"
.br
.ti -1c
.RI "int \fBsignal_init\fP (void)"
.br
.RI "Main function for initialising signals\&. "
.ti -1c
.RI "void \fBreset_signal_default\fP (void)"
.br
.RI "Function to reset signals to default\&. "
.ti -1c
.RI "void \fBignore_signal\fP (void)"
.br
.RI "Function to ignore certain signals\&. "
.ti -1c
.RI "char * \fBget_prompt_message\fP (void)"
.br
.RI "Build the prompt message If an error occurs, returns the static default prompt message\&. "
.ti -1c
.RI "ssize_t \fBprint_fd\fP (int fd, const char *str)"
.br
.RI "Function used to write safely and exits if write failed\&. "
.ti -1c
.RI "ssize_t \fBprintn_fd\fP (int fd, const char *str, size_t len)"
.br
.RI "Function used to write safely and exits if write failed\&. "
.ti -1c
.RI "void \fBprint_command_fd\fP (\fBt_command\fP *command)"
.br
.RI "Print the file descriptor of command into stderr\&. "
.ti -1c
.RI "char * \fBft_substr_end\fP (char const *src, unsigned int start, size_t end)"
.br
.RI "Allocate memory for a string and copy the content from src\&. "
.ti -1c
.RI "int \fBis_operator_char\fP (char c)"
.br
.RI "Is |, < or > "
.ti -1c
.RI "char ** \fBlexer\fP (const char *line)"
.br
.RI "Create tokens (small chunks) a line with the quotes and operators\&. "
.ti -1c
.RI "\fBt_command\fP * \fBtokeniser\fP (char **tokens, char **envp)"
.br
.RI "Creates a \fBt_command\fP structure that contains all the tokens Fills the command with the environment\&. "
.ti -1c
.RI "char ** \fBparse_line\fP (char *line)"
.br
.RI "Prototype for parsing\&. "
.ti -1c
.RI "char ** \fBexpand_tildes_tokens\fP (char **tokens)"
.br
.RI "Expands all the tildes found in array with HOME\&. "
.ti -1c
.RI "char ** \fBcopy_toks\fP (\fBt_command\fP *command)"
.br
.RI "Creates a copy of all tokens that are in a command structure It's used for forks during exec\&. "
.ti -1c
.RI "void \fBprint_toks\fP (char **tokens)"
.br
.RI "Print tokens indexed\&. "
.ti -1c
.RI "int \fBprepare_command\fP (\fBt_command\fP *command, int ret)"
.br
.RI "Prepare the command for \fBsearch_command()\fP "
.ti -1c
.RI "int \fBprepare_command_forks\fP (\fBt_command\fP *command, int ret)"
.br
.ti -1c
.RI "int \fBsearch_command\fP (\fBt_command\fP *command, char **tokens, int ret)"
.br
.RI "Search if command is a builtin or not\&. "
.ti -1c
.RI "int \fBnot_builtins\fP (\fBt_command\fP *command, char **tokens)"
.br
.RI "Executes commands that are not builtins\&. "
.ti -1c
.RI "int \fBhandle_redirections\fP (\fBt_command\fP *command)"
.br
.RI "Create and redirect inputs and outputs needed for the command\&. "
.ti -1c
.RI "void \fBreset_redirection\fP (\fBt_command\fP *command, unsigned char i)"
.br
.RI "Reset redirections by default values Replace the new redirections by stdin and stdout\&. "
.ti -1c
.RI "int \fBneeds_to_be_forked\fP (\fBt_command\fP *command)"
.br
.RI "Check if it needs to be forked\&. "
.ti -1c
.RI "void \fBexecutes_in_forks\fP (\fBt_command\fP *command, char **tokens, int ret)"
.br
.RI "Executes the command in a forks\&. "
.ti -1c
.RI "int \fBcreate_pipe\fP (\fBt_command\fP *command)"
.br
.RI "Change the previous input of pipe to a new redirection\&. "
.ti -1c
.RI "void \fBfree_array\fP (char **array)"
.br
.RI "Free array of strings\&. "
.ti -1c
.RI "void \fBfree_command\fP (\fBt_command\fP *command)"
.br
.RI "Free \fBt_command\fP linked list structure with all that it contains\&. "
.ti -1c
.RI "void \fBfree_files_struct\fP (\fBt_file\fP *file)"
.br
.RI "Free linked list of \fBt_file\fP structure\&. "
.ti -1c
.RI "void \fBfree_heredoc\fP (\fBt_tmp\fP *tmp)"
.br
.RI "Free heredoc structure\&. "
.ti -1c
.RI "void \fBfree_tokens\fP (\fBt_token\fP *token)"
.br
.RI "Free t_tokens linked list structure\&. "
.ti -1c
.RI "void \fBprint_list_files\fP (\fBt_command\fP *command)"
.br
.RI "Print the list of files in the command structure\&. "
.ti -1c
.RI "void \fBprint_perm_files\fP (\fBt_command\fP *command)"
.br
.RI "Print the list of permissions of files in the command structure\&. "
.ti -1c
.RI "ssize_t \fBprint_command\fP (\fBt_command\fP *command)"
.br
.RI "Print the command structure with it's tokens\&. "
.ti -1c
.RI "ssize_t \fBprint_commands\fP (\fBt_command\fP *command)"
.br
.RI "Print the commands structure with it's tokens\&. "
.in -1c
.SH "Macro Definition Documentation"
.PP 
.SS "#define FOLLOW_ZSH   0"

.SS "#define PROMPT_MESSAGE_CUSTOM   1"

.SH "Typedef Documentation"
.PP 
.SS "typedef struct \fBs_command\fP \fBt_command\fP"

.SS "typedef struct \fBs_lexer_state\fP \fBt_lexer_state\fP"

.SS "typedef struct \fBs_token\fP \fBt_token\fP"

.SH "Function Documentation"
.PP 
.SS "char ** copy_toks (\fBt_command\fP * command)"

.PP
Creates a copy of all tokens that are in a command structure It's used for forks during exec\&. 
.PP
\fBParameters\fP
.RS 4
\fIcommand\fP command structure 
.RE
.PP
\fBReturns\fP
.RS 4
char** copy of tokens 
.RE
.PP

.SS "int create_pipe (\fBt_command\fP * command)"

.PP
Change the previous input of pipe to a new redirection\&. 
.PP
\fBParameters\fP
.RS 4
\fIcommand\fP command structure 
.br
\fIin_out\fP 0 = IN, 1 = OUT 
.RE
.PP

.SS "void executes_in_forks (\fBt_command\fP * command, char ** tokens, int ret)"

.PP
Executes the command in a forks\&. 
.PP
\fBParameters\fP
.RS 4
\fIcommand\fP command structure 
.br
\fItokens\fP array of strings 
.br
\fIret\fP return value of previous command 
.RE
.PP

.SS "char ** expand_tildes_tokens (char ** tokens)"

.PP
Expands all the tildes found in array with HOME\&. 
.PP
\fBParameters\fP
.RS 4
\fItokens\fP array of strings 
.RE
.PP
\fBReturns\fP
.RS 4
char** tokens if OK, NULL otherwise 
.RE
.PP

.SS "void free_array (char ** array)"

.PP
Free array of strings\&. 
.PP
\fBParameters\fP
.RS 4
\fIarray\fP array of strings 
.RE
.PP

.SS "void free_command (\fBt_command\fP * command)"

.PP
Free \fBt_command\fP linked list structure with all that it contains\&. 
.PP
\fBParameters\fP
.RS 4
\fIcommand\fP head of \fBt_command\fP linked list structure 
.RE
.PP

.SS "void free_files_struct (\fBt_file\fP * file)"

.PP
Free linked list of \fBt_file\fP structure\&. 
.PP
\fBParameters\fP
.RS 4
\fIfile\fP head of \fBt_file\fP linked list structure 
.RE
.PP

.SS "void free_heredoc (\fBt_tmp\fP * tmp)"

.PP
Free heredoc structure\&. 
.PP
\fBParameters\fP
.RS 4
\fItmp\fP heredoc structure 
.RE
.PP

.SS "void free_tokens (\fBt_token\fP * token)"

.PP
Free t_tokens linked list structure\&. 
.PP
\fBParameters\fP
.RS 4
\fItoken\fP head of t_tokens linked list structure 
.RE
.PP

.SS "char * ft_substr_end (char const * src, unsigned int start, size_t end)"

.PP
Allocate memory for a string and copy the content from src\&. 
.PP
\fBParameters\fP
.RS 4
\fIsrc\fP source string 
.br
\fIstart\fP start index to copy from 
.br
\fIend\fP end index to copy to 
.RE
.PP
\fBReturns\fP
.RS 4
char* pointer to the new string 
.RE
.PP

.SS "char * get_prompt_message (void )"

.PP
Build the prompt message If an error occurs, returns the static default prompt message\&. 
.PP
\fBReturns\fP
.RS 4
char* prompt message 
.RE
.PP

.SS "int handle_redirections (\fBt_command\fP * command)"

.PP
Create and redirect inputs and outputs needed for the command\&. 
.PP
\fBParameters\fP
.RS 4
\fIcommand\fP command structure 
.RE
.PP
\fBReturns\fP
.RS 4
int 0 or positive OK, negative ERROR 
.RE
.PP

.SS "void ignore_signal (void )"

.PP
Function to ignore certain signals\&. 
.SS "int is_operator_char (char c)"

.PP
Is |, < or > 
.PP
\fBParameters\fP
.RS 4
\fIc\fP character to check 
.RE
.PP
\fBReturns\fP
.RS 4
int 1 if c is operator, 0 otherwise 
.RE
.PP

.SS "char ** lexer (const char * line)"

.PP
Create tokens (small chunks) a line with the quotes and operators\&. Handle spaces, quotes (' and ') and shell operator (|, <, <<, >, >>)\&. Return an array of tokens (strings), NULL terminated\&.

.PP
\fBParameters\fP
.RS 4
\fIline\fP line to tokenise 
.RE
.PP
\fBReturns\fP
.RS 4
Array of strings 
.RE
.PP

.SS "int minishell (char ** envp)"

.PP
Minishell that handles all the shell functions\&. 
.PP
\fBParameters\fP
.RS 4
\fIenvp\fP environmment 
.RE
.PP
\fBReturns\fP
.RS 4
int 
.RE
.PP

.SS "int needs_to_be_forked (\fBt_command\fP * command)"

.PP
Check if it needs to be forked\&. 
.PP
\fBParameters\fP
.RS 4
\fIcommand\fP command structure 
.RE
.PP
\fBReturns\fP
.RS 4
int 0 NO, 1 YES 
.RE
.PP

.SS "int not_builtins (\fBt_command\fP * command, char ** tokens)"

.PP
Executes commands that are not builtins\&. 
.PP
\fBParameters\fP
.RS 4
\fIcommand\fP command structure 
.br
\fItokens\fP array of strings 
.RE
.PP
\fBReturns\fP
.RS 4
int 
.RE
.PP

.SS "char ** parse_line (char * line)"

.PP
Prototype for parsing\&. 
.PP
\fBParameters\fP
.RS 4
\fIline\fP line to parse 
.RE
.PP
\fBReturns\fP
.RS 4
char** 
.RE
.PP

.SS "int prepare_command (\fBt_command\fP * command, int ret)"

.PP
Prepare the command for \fBsearch_command()\fP 
.PP
\fBParameters\fP
.RS 4
\fIcommand\fP command structure 
.RE
.PP
\fBReturns\fP
.RS 4
int 
.RE
.PP

.SS "int prepare_command_forks (\fBt_command\fP * command, int ret)"

.SS "ssize_t print_command (\fBt_command\fP * command)"

.PP
Print the command structure with it's tokens\&. 
.PP
\fBParameters\fP
.RS 4
\fIcommand\fP command structure 
.RE
.PP
\fBReturns\fP
.RS 4
ssize_t 0 or positive is OK, otherwise error 
.RE
.PP

.SS "void print_command_fd (\fBt_command\fP * command)"

.PP
Print the file descriptor of command into stderr\&. 
.PP
\fBParameters\fP
.RS 4
\fIcommand\fP command structure 
.RE
.PP

.SS "ssize_t print_commands (\fBt_command\fP * command)"

.PP
Print the commands structure with it's tokens\&. 
.PP
\fBParameters\fP
.RS 4
\fIcommand\fP command structure 
.RE
.PP
\fBReturns\fP
.RS 4
ssize_t 0 or positive is OK, otherwise error 
.RE
.PP

.SS "ssize_t print_fd (int fd, const char * str)"

.PP
Function used to write safely and exits if write failed\&. 
.PP
\fBParameters\fP
.RS 4
\fIfd\fP file descriptor 
.br
\fIstr\fP string to print 
.RE
.PP
\fBReturns\fP
.RS 4
ssize_t number of character printed 
.RE
.PP

.SS "void print_list_files (\fBt_command\fP * command)"

.PP
Print the list of files in the command structure\&. 
.PP
\fBParameters\fP
.RS 4
\fIcommand\fP command structure 
.RE
.PP

.SS "void print_perm_files (\fBt_command\fP * command)"

.PP
Print the list of permissions of files in the command structure\&. 
.PP
\fBParameters\fP
.RS 4
\fIcommand\fP command structure 
.RE
.PP

.SS "void print_toks (char ** tokens)"

.PP
Print tokens indexed\&. 
.PP
\fBParameters\fP
.RS 4
\fItokens\fP tokens to print 
.RE
.PP

.SS "ssize_t printn_fd (int fd, const char * str, size_t len)"

.PP
Function used to write safely and exits if write failed\&. 
.PP
\fBParameters\fP
.RS 4
\fIfd\fP file descriptor 
.br
\fIstr\fP string to print 
.br
\fIlen\fP number of character to print 
.RE
.PP
\fBReturns\fP
.RS 4
ssize_t number of character printed 
.RE
.PP

.SS "int read_context (char ** envp)"

.PP
Function to read the context where this function is called Verify if it's used in a tty or not\&. 
.PP
\fBParameters\fP
.RS 4
\fIenvp\fP environment 
.RE
.PP
\fBReturns\fP
.RS 4
int 0 OK, 1 otherwise 
.RE
.PP

.SS "void reset_redirection (\fBt_command\fP * command, unsigned char i)"

.PP
Reset redirections by default values Replace the new redirections by stdin and stdout\&. 
.PP
\fBParameters\fP
.RS 4
\fIcommand\fP command structure 
.br
\fIi\fP value used for recursion 
.RE
.PP

.SS "void reset_signal_default (void )"

.PP
Function to reset signals to default\&. 
.SS "int search_command (\fBt_command\fP * command, char ** tokens, int ret)"

.PP
Search if command is a builtin or not\&. 
.PP
\fBParameters\fP
.RS 4
\fIcommand\fP command structure 
.br
\fItokens\fP array of strings 
.br
\fIret\fP return value of previous command 
.RE
.PP
\fBReturns\fP
.RS 4
int 0 if command found, 1 otherwise 
.RE
.PP

.SS "void short_minishell_no_tty (char ** envp)"

.SS "int signal_init (void )"

.PP
Main function for initialising signals\&. 
.PP
\fBReturns\fP
.RS 4
int 0 if the function ends correctly, -1 otherwise\&. 
.RE
.PP

.SS "\fBt_command\fP * tokeniser (char ** tokens, char ** envp)"

.PP
Creates a \fBt_command\fP structure that contains all the tokens Fills the command with the environment\&. 
.PP
\fBParameters\fP
.RS 4
\fItokens\fP tokens 
.br
\fIenvp\fP environment 
.RE
.PP
\fBReturns\fP
.RS 4
t_command* pointer if OK, NULL if it fails 
.RE
.PP

.SH "Author"
.PP 
Generated automatically by Doxygen for Minishell from the source code\&.
