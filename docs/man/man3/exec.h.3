.TH "inc/exec.h" 3 "Minishell" \" -*- nroff -*-
.ad l
.nh
.SH NAME
inc/exec.h
.SH SYNOPSIS
.br
.PP
\fR#include 'data_structure\&.h'\fP
.br

.SS "Functions"

.in +1c
.ti -1c
.RI "char ** \fBcopy_toks\fP (\fBt_data\fP *data, \fBt_command\fP *command)"
.br
.RI "Creates a copy of all tokens that are in a command structure It's used for forks during exec\&. "
.ti -1c
.RI "int \fBprepare_command\fP (\fBt_data\fP *data)"
.br
.RI "Prepare the command for \fBsearch_command()\fP "
.ti -1c
.RI "int \fBprepare_command_forks\fP (\fBt_data\fP *data)"
.br
.ti -1c
.RI "int \fBsearch_command\fP (\fBt_data\fP *data, \fBt_command\fP *command, char **tokens)"
.br
.RI "Search if command is a builtin or not\&. "
.ti -1c
.RI "int \fBnot_builtins\fP (\fBt_data\fP *data, \fBt_command\fP *command, char **tokens)"
.br
.RI "Executes commands that are not builtins\&. "
.ti -1c
.RI "int \fBhandle_redirections\fP (\fBt_garbage\fP *garbage, \fBt_command\fP *command, int fd_backup[2])"
.br
.RI "Create and redirect inputs and outputs needed for the command\&. "
.ti -1c
.RI "void \fBreset_redirection\fP (\fBt_garbage\fP *garbage, \fBt_command\fP *command, int fd_backup[2], unsigned char i)"
.br
.RI "Reset redirections by default values Replace the new redirections by stdin and stdout\&. "
.ti -1c
.RI "int \fBneeds_to_be_forked\fP (\fBt_command\fP *command)"
.br
.RI "Check if it needs to be forked\&. "
.ti -1c
.RI "int \fBexecve_fork\fP (\fBt_data\fP *data, char *path, char **toks, char **envp)"
.br
.ti -1c
.RI "int \fBcreate_pipe\fP (\fBt_command\fP *command)"
.br
.ti -1c
.RI "int \fBhandle_redirections_forks\fP (\fBt_garbage\fP *garbage, \fBt_command\fP *command)"
.br
.RI "Create and redirect inputs and outputs needed for the command\&. "
.ti -1c
.RI "size_t \fBcount_commands\fP (\fBt_command\fP *command)"
.br
.RI "Cound the number of commands in the command structure\&. "
.ti -1c
.RI "int \fBsafe_close\fP (int *fd)"
.br
.RI "Safely close fd\&. "
.ti -1c
.RI "void \fBdup_and_close\fP (\fBt_garbage\fP *garbage, int oldfd, int newfd)"
.br
.RI "Special dup2 that also closes the old fd\&. "
.ti -1c
.RI "void \fBexecute_pipeline\fP (\fBt_data\fP *data, pid_t *pids, size_t *count)"
.br
.RI "Execute all the command that are followed by pipes\&. "
.ti -1c
.RI "void \fBfill_toks_into_commands\fP (\fBt_data\fP *data, \fBt_command\fP *command)"
.br
.ti -1c
.RI "void \fBsearch_path\fP (\fBt_data\fP *data, \fBt_command\fP *command)"
.br
.RI "Search path for the designated command\&. "
.ti -1c
.RI "void \fBsearch_paths\fP (\fBt_data\fP *data, \fBt_command\fP *command)"
.br
.RI "Search Path for all commands\&. "
.ti -1c
.RI "void \fBwait_all_childs\fP (\fBt_command\fP *command, pid_t *pids)"
.br
.RI "Waits for all the childs with their pids\&. "
.in -1c
.SH "Function Documentation"
.PP 
.SS "char ** copy_toks (\fBt_data\fP * data, \fBt_command\fP * command)"

.PP
Creates a copy of all tokens that are in a command structure It's used for forks during exec\&. 
.PP
\fBParameters\fP
.RS 4
\fIcommand\fP command structure 
.RE
.PP
\fBReturns\fP
.RS 4
char** copy of tokens 
.RE
.PP

.SS "size_t count_commands (\fBt_command\fP * command)"

.PP
Cound the number of commands in the command structure\&. 
.PP
\fBParameters\fP
.RS 4
\fIcommand\fP command structure 
.RE
.PP
\fBReturns\fP
.RS 4
size_t number of commands 
.RE
.PP

.SS "int create_pipe (\fBt_command\fP * command)"

.SS "void dup_and_close (\fBt_garbage\fP * garbage, int oldfd, int newfd)"

.PP
Special dup2 that also closes the old fd\&. 
.PP
\fBParameters\fP
.RS 4
\fIoldfd\fP fd that will overwrite newfd and will be close 
.br
\fInewfd\fP fd to overwrite by oldfd 
.RE
.PP

.SS "void execute_pipeline (\fBt_data\fP * data, pid_t * pids, size_t * count)"

.PP
Execute all the command that are followed by pipes\&. 
.PP
\fBParameters\fP
.RS 4
\fIdata\fP data structure 
.br
\fIpids\fP array of pids of childs 
.RE
.PP

.SS "int execve_fork (\fBt_data\fP * data, char * path, char ** toks, char ** envp)"

.SS "void fill_toks_into_commands (\fBt_data\fP * data, \fBt_command\fP * command)"

.SS "int handle_redirections (\fBt_garbage\fP * garbage, \fBt_command\fP * command, int fd_backup[2])"

.PP
Create and redirect inputs and outputs needed for the command\&. 
.PP
\fBParameters\fP
.RS 4
\fIcommand\fP command structure 
.RE
.PP
\fBReturns\fP
.RS 4
int 0 or positive OK, negative ERROR 
.RE
.PP

.SS "int handle_redirections_forks (\fBt_garbage\fP * garbage, \fBt_command\fP * command)"

.PP
Create and redirect inputs and outputs needed for the command\&. 
.PP
\fBParameters\fP
.RS 4
\fIcommand\fP command structure 
.RE
.PP
\fBReturns\fP
.RS 4
int 0 or positive OK, negative ERROR 
.RE
.PP

.SS "int needs_to_be_forked (\fBt_command\fP * command)"

.PP
Check if it needs to be forked\&. 
.PP
\fBParameters\fP
.RS 4
\fIcommand\fP command structure 
.RE
.PP
\fBReturns\fP
.RS 4
int 0 NO, 1 YES 
.RE
.PP

.SS "int not_builtins (\fBt_data\fP * data, \fBt_command\fP * command, char ** tokens)"

.PP
Executes commands that are not builtins\&. 
.PP
\fBParameters\fP
.RS 4
\fIcommand\fP command structure 
.br
\fItokens\fP array of strings 
.RE
.PP
\fBReturns\fP
.RS 4
int 
.RE
.PP

.SS "int prepare_command (\fBt_data\fP * data)"

.PP
Prepare the command for \fBsearch_command()\fP 
.PP
\fBParameters\fP
.RS 4
\fIdata\fP data structure 
.RE
.PP
\fBReturns\fP
.RS 4
int 
.RE
.PP

.SS "int prepare_command_forks (\fBt_data\fP * data)"

.SS "void reset_redirection (\fBt_garbage\fP * garbage, \fBt_command\fP * command, int fd_backup[2], unsigned char i)"

.PP
Reset redirections by default values Replace the new redirections by stdin and stdout\&. 
.PP
\fBParameters\fP
.RS 4
\fIcommand\fP command structure 
.br
\fIi\fP value used for recursion 
.RE
.PP

.SS "int safe_close (int * fd)"

.PP
Safely close fd\&. 
.PP
\fBParameters\fP
.RS 4
\fIfd\fP file descriptor to close 
.RE
.PP
\fBReturns\fP
.RS 4
0 no error, 1 ERROR 
.RE
.PP

.SS "int search_command (\fBt_data\fP * data, \fBt_command\fP * command, char ** tokens)"

.PP
Search if command is a builtin or not\&. 
.PP
\fBParameters\fP
.RS 4
\fIcommand\fP command structure 
.br
\fItokens\fP array of strings 
.RE
.PP
\fBReturns\fP
.RS 4
int 0 if command found, 1 otherwise 
.RE
.PP

.SS "void search_path (\fBt_data\fP * data, \fBt_command\fP * command)"

.PP
Search path for the designated command\&. 
.PP
\fBParameters\fP
.RS 4
\fIdata\fP data structure 
.br
\fIcommand\fP command structure 
.RE
.PP

.SS "void search_paths (\fBt_data\fP * data, \fBt_command\fP * command)"

.PP
Search Path for all commands\&. 
.PP
\fBParameters\fP
.RS 4
\fIdata\fP data structure 
.br
\fIcommand\fP command structure 
.RE
.PP

.SS "void wait_all_childs (\fBt_command\fP * command, pid_t * pids)"

.PP
Waits for all the childs with their pids\&. 
.PP
\fBParameters\fP
.RS 4
\fIcommand\fP command structure 
.br
\fIpids\fP array of pids of childs 
.RE
.PP

.SH "Author"
.PP 
Generated automatically by Doxygen for Minishell from the source code\&.
