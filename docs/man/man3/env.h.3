.TH "inc/env.h" 3 "Minishell" \" -*- nroff -*-
.ad l
.nh
.SH NAME
inc/env.h
.SH SYNOPSIS
.br
.PP
\fR#include 'garbage\&.h'\fP
.br
\fR#include 'libft\&.h'\fP
.br
\fR#include <stddef\&.h>\fP
.br

.SS "Data Structures"

.in +1c
.ti -1c
.RI "struct \fBs_env_vars\fP"
.br
.ti -1c
.RI "struct \fBs_var\fP"
.br
.ti -1c
.RI "struct \fBs_params\fP"
.br
.ti -1c
.RI "struct \fBs_vars\fP"
.br
.ti -1c
.RI "struct \fBs_supp\fP"
.br
.in -1c
.SS "Macros"

.in +1c
.ti -1c
.RI "#define \fBDEFAULT_PROMPT\fP   'Minishell$ '"
.br
.ti -1c
.RI "#define \fBPROMPT_COLOR\fP   1"
.br
.ti -1c
.RI "#define \fBCOLOR_OFF\fP   '\\033[0m'"
.br
.ti -1c
.RI "#define \fBCYAN_COLOR\fP   '\\033[0;36m'"
.br
.ti -1c
.RI "#define \fBPURPLE_COLOR\fP   '\\033[0;35m'"
.br
.in -1c
.SS "Typedefs"

.in +1c
.ti -1c
.RI "typedef struct \fBs_vars\fP \fBt_vars\fP"
.br
.ti -1c
.RI "typedef struct \fBs_supp\fP \fBt_supp\fP"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "int \fBcheck_args_export\fP (const char *str)"
.br
.ti -1c
.RI "size_t \fBft_strlen_choose_c\fP (const char *str, char c)"
.br
.ti -1c
.RI "int \fBft_strcmp\fP (const char *s1, const char *s2)"
.br
.ti -1c
.RI "void \fBprint_env_vars\fP (\fBt_env_vars\fP *env)"
.br
.ti -1c
.RI "t_bool \fBdetect_equal\fP (char *str)"
.br
.ti -1c
.RI "char ** \fBbuild_elements\fP (char *str)"
.br
.ti -1c
.RI "\fBt_env_vars\fP * \fBinit_env\fP (char **envp)"
.br
.ti -1c
.RI "\fBt_env_vars\fP * \fBcopy_env\fP (\fBt_garbage\fP *garbage, \fBt_env_vars\fP *env)"
.br
.ti -1c
.RI "void \fBset_env\fP (\fBt_data\fP *data, char *envp[])"
.br
.ti -1c
.RI "void \fBsort_ascii_order\fP (\fBt_garbage\fP *garbage, \fBt_env_vars\fP *env)"
.br
.ti -1c
.RI "char * \fBsearch_env_str\fP (\fBt_garbage\fP *garbage, \fBt_env_vars\fP *env, const char *var, size_t size)"
.br
.ti -1c
.RI "\fBt_var\fP * \fBsearch_env_var\fP (\fBt_env_vars\fP *env, char *var)"
.br
.ti -1c
.RI "int \fBcount_env\fP (\fBt_env_vars\fP env)"
.br
.ti -1c
.RI "void \fBupdate_shlvl\fP (\fBt_garbage\fP *garbage, \fBt_env_vars\fP *env)"
.br
.ti -1c
.RI "char ** \fBenv_to_array\fP (\fBt_data\fP *data)"
.br
.ti -1c
.RI "char * \fBcreate_str_with_params\fP (\fBt_garbage\fP *garbage, \fBt_params\fP *params)"
.br
.ti -1c
.RI "\fBt_params\fP * \fBget_param\fP (\fBt_garbage\fP *garbage, char *content, size_t \fBdetect_equal\fP)"
.br
.ti -1c
.RI "\fBt_params\fP * \fBft_paramlast\fP (\fBt_params\fP *params)"
.br
.ti -1c
.RI "void \fBreplace_param\fP (\fBt_garbage\fP *garbage, \fBt_var\fP *var, char *new_content, size_t equal)"
.br
.ti -1c
.RI "void \fBft_paramsadd_back\fP (\fBt_params\fP **params, \fBt_params\fP *new)"
.br
.ti -1c
.RI "void \fBprint_export\fP (\fBt_env_vars\fP *env)"
.br
.ti -1c
.RI "\fBt_var\fP * \fBft_varlast\fP (\fBt_var\fP *var)"
.br
.ti -1c
.RI "\fBt_var\fP * \fBget_var\fP (\fBt_garbage\fP *garbage, const char *var)"
.br
.ti -1c
.RI "void \fBft_varsadd_back\fP (\fBt_var\fP **var, \fBt_var\fP *new)"
.br
.ti -1c
.RI "void \fBft_varsadd_front\fP (\fBt_var\fP **head, \fBt_var\fP *new)"
.br
.ti -1c
.RI "void \fBsupp_var\fP (\fBt_garbage\fP *garbage, \fBt_var\fP **head, char *str)"
.br
.ti -1c
.RI "void \fBswap_vars\fP (\fBt_garbage\fP *garbage, \fBt_var\fP **head, char *str, char *str_1)"
.br
.ti -1c
.RI "void \fBbubble_sort\fP (\fBt_garbage\fP *garbage, \fBt_var\fP **head)"
.br
.ti -1c
.RI "void \fBfree_params\fP (\fBt_garbage\fP *garbage, \fBt_params\fP *element)"
.br
.ti -1c
.RI "void \fBfree_env\fP (\fBt_garbage\fP *garbage, \fBt_env_vars\fP *env)"
.br
.in -1c
.SH "Macro Definition Documentation"
.PP 
.SS "#define COLOR_OFF   '\\033[0m'"

.SS "#define CYAN_COLOR   '\\033[0;36m'"

.SS "#define DEFAULT_PROMPT   'Minishell$ '"

.SS "#define PROMPT_COLOR   1"

.SS "#define PURPLE_COLOR   '\\033[0;35m'"

.SH "Typedef Documentation"
.PP 
.SS "typedef struct \fBs_supp\fP \fBt_supp\fP"

.SS "typedef struct \fBs_vars\fP \fBt_vars\fP"

.SH "Function Documentation"
.PP 
.SS "void bubble_sort (\fBt_garbage\fP * garbage, \fBt_var\fP ** head)"

.SS "char ** build_elements (char * str)"

.SS "int check_args_export (const char * str)"

.SS "\fBt_env_vars\fP * copy_env (\fBt_garbage\fP * garbage, \fBt_env_vars\fP * env)"

.SS "int count_env (\fBt_env_vars\fP env)"

.SS "char * create_str_with_params (\fBt_garbage\fP * garbage, \fBt_params\fP * params)"

.SS "t_bool detect_equal (char * str)"

.SS "char ** env_to_array (\fBt_data\fP * data)"

.SS "void free_env (\fBt_garbage\fP * garbage, \fBt_env_vars\fP * env)"

.SS "void free_params (\fBt_garbage\fP * garbage, \fBt_params\fP * element)"

.SS "\fBt_params\fP * ft_paramlast (\fBt_params\fP * params)"

.SS "void ft_paramsadd_back (\fBt_params\fP ** params, \fBt_params\fP * new)"

.SS "int ft_strcmp (const char * s1, const char * s2)"

.SS "size_t ft_strlen_choose_c (const char * str, char c)"

.SS "\fBt_var\fP * ft_varlast (\fBt_var\fP * var)"

.SS "void ft_varsadd_back (\fBt_var\fP ** var, \fBt_var\fP * new)"

.SS "void ft_varsadd_front (\fBt_var\fP ** head, \fBt_var\fP * new)"

.SS "\fBt_params\fP * get_param (\fBt_garbage\fP * garbage, char * content, size_t detect_equal)"

.SS "\fBt_var\fP * get_var (\fBt_garbage\fP * garbage, const char * var)"

.SS "\fBt_env_vars\fP * init_env (char ** envp)"

.SS "void print_env_vars (\fBt_env_vars\fP * env)"

.SS "void print_export (\fBt_env_vars\fP * env)"

.SS "void replace_param (\fBt_garbage\fP * garbage, \fBt_var\fP * var, char * new_content, size_t equal)"

.SS "char * search_env_str (\fBt_garbage\fP * garbage, \fBt_env_vars\fP * env, const char * var, size_t size)"

.SS "\fBt_var\fP * search_env_var (\fBt_env_vars\fP * env, char * var)"

.SS "void set_env (\fBt_data\fP * data, char * envp[])"

.SS "void sort_ascii_order (\fBt_garbage\fP * garbage, \fBt_env_vars\fP * env)"

.SS "void supp_var (\fBt_garbage\fP * garbage, \fBt_var\fP ** head, char * str)"

.SS "void swap_vars (\fBt_garbage\fP * garbage, \fBt_var\fP ** head, char * str, char * str_1)"

.SS "void update_shlvl (\fBt_garbage\fP * garbage, \fBt_env_vars\fP * env)"

.SH "Author"
.PP 
Generated automatically by Doxygen for Minishell from the source code\&.
