.TH "inc/file.h" 3 "Minishell" \" -*- nroff -*-
.ad l
.nh
.SH NAME
inc/file.h
.SH SYNOPSIS
.br
.PP
\fR#include 'libft\&.h'\fP
.br
\fR#include 'minishell\&.h'\fP
.br

.SS "Data Structures"

.in +1c
.ti -1c
.RI "struct \fBs_tmp\fP"
.br
.ti -1c
.RI "struct \fBs_file\fP"
.br
.in -1c
.SS "Macros"

.in +1c
.ti -1c
.RI "#define \fBTMP_PATH\fP   '/tmp/'"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "int \fBfiles_management\fP (\fBt_data\fP *data)"
.br
.RI "Executes all the files redirection tests\&. "
.ti -1c
.RI "int \fBbuild_files_redirection\fP (\fBt_data\fP *data)"
.br
.RI "Adds files to the file redirection structure\&. "
.ti -1c
.RI "void * \fBadd_file\fP (\fBt_garbage\fP *garbage, \fBt_command\fP *command, \fBt_token\fP *token, \fBt_file\fP **command_file)"
.br
.RI "Add a file to the stack given in param, each file added is at the beginning of the stack (reverse order) "
.ti -1c
.RI "int \fBbuild_files_data\fP (\fBt_command\fP *command)"
.br
.RI "Build the data around the files in all commands\&. "
.ti -1c
.RI "\fBt_command\fP * \fBremove_used_file_tokens\fP (\fBt_data\fP *data)"
.br
.RI "Removes all the tokens of file redirections allready used\&. "
.ti -1c
.RI "int \fBbuild_file_access\fP (\fBt_file\fP *file)"
.br
.RI "Build the file using access and check permissions\&. "
.ti -1c
.RI "char * \fBft_trim_word\fP (char *str)"
.br
.ti -1c
.RI "\fBt_file\fP * \fBfile_parser\fP (\fBt_file\fP *file)"
.br
.RI "Parse the file structure\&. "
.ti -1c
.RI "\fBt_tmp\fP \fBcreate_tmp\fP (\fBt_garbage\fP *garbage, char *path, int nbr_try)"
.br
.RI "Create a tmp file, verify if it already exist, tries to open it to verify permissions, and returns the result\&. "
.ti -1c
.RI "char * \fBread_heredoc\fP (\fBt_tmp\fP *tmp, char *delimiteur)"
.br
.RI "Read from stdin and outputs to a file, stops reading when Ctrl+D or when a delimitor is found\&. "
.ti -1c
.RI "int \fBverify_access\fP (\fBt_garbage\fP *garbage, \fBt_command\fP *command)"
.br
.RI "Verify that all files are valid if at least one file is invalid, modifies the boolean in command but still return 0\&. "
.ti -1c
.RI "\fBt_file\fP * \fBsearch_last_file\fP (\fBt_file\fP *file, \fBt_file\fP *already_searched)"
.br
.RI "Return the last file that is not already_searched\&. "
.ti -1c
.RI "int \fBfill_heredocs\fP (\fBt_garbage\fP *garbage, \fBt_command\fP *command)"
.br
.RI "Fill all the heredocs in the correct order\&. "
.ti -1c
.RI "int \fBopen_file_with_rights\fP (\fBt_garbage\fP *garbage, \fBt_file\fP *file, t_bool in_out)"
.br
.RI "Open a file with it's rights (permissions) "
.ti -1c
.RI "void \fBread_write_to\fP (\fBt_garbage\fP *garbage, \fBt_command\fP *command, t_bool in_out)"
.br
.RI "Opens the files to read and writes\&. "
.ti -1c
.RI "void \fBfd_default\fP (\fBt_command\fP *command)"
.br
.RI "Put the fds in command to there default values\&. "
.in -1c
.SH "Macro Definition Documentation"
.PP 
.SS "#define TMP_PATH   '/tmp/'"

.SH "Function Documentation"
.PP 
.SS "void * add_file (\fBt_garbage\fP * garbage, \fBt_command\fP * command, \fBt_token\fP * token, \fBt_file\fP ** command_file)"

.PP
Add a file to the stack given in param, each file added is at the beginning of the stack (reverse order) 
.PP
\fBParameters\fP
.RS 4
\fIcommand\fP command structure 
.br
\fItoken\fP token containing str informations 
.br
\fIcommand_file\fP stack to assign a file 
.RE
.PP
\fBReturns\fP
.RS 4
void* NULL if error, command if no stack given, and file if all's good 
.RE
.PP

.SS "int build_file_access (\fBt_file\fP * file)"

.PP
Build the file using access and check permissions\&. 
.PP
\fBParameters\fP
.RS 4
\fIfile\fP file structure 
.RE
.PP
\fBReturns\fP
.RS 4
int 0, OK, -1 error 
.RE
.PP

.SS "int build_files_data (\fBt_command\fP * command)"

.PP
Build the data around the files in all commands\&. 
.PP
\fBParameters\fP
.RS 4
\fIcommand\fP file structure 
.RE
.PP
\fBReturns\fP
.RS 4
int 0 OK, 1 error 
.RE
.PP

.SS "int build_files_redirection (\fBt_data\fP * data)"

.PP
Adds files to the file redirection structure\&. 
.PP
\fBParameters\fP
.RS 4
\fIdata\fP data structure 
.RE
.PP
\fBReturns\fP
.RS 4
int 0, OK, -1 error 
.RE
.PP

.SS "\fBt_tmp\fP create_tmp (\fBt_garbage\fP * garbage, char * path, int nbr_try)"

.PP
Create a tmp file, verify if it already exist, tries to open it to verify permissions, and returns the result\&. 
.PP
\fBParameters\fP
.RS 4
\fIpath\fP path where to create the file 
.br
\fInbr_try\fP number of try to create a tmp file 
.RE
.PP
\fBReturns\fP
.RS 4
\fBt_tmp\fP structure with the path+name of created name 
.RE
.PP

.SS "void fd_default (\fBt_command\fP * command)"

.PP
Put the fds in command to there default values\&. 
.PP
\fBParameters\fP
.RS 4
\fIcommand\fP command structure 
.RE
.PP

.SS "\fBt_file\fP * file_parser (\fBt_file\fP * file)"

.PP
Parse the file structure\&. 
.PP
\fBParameters\fP
.RS 4
\fIfile\fP file structure 
.RE
.PP
\fBReturns\fP
.RS 4
t_file* file given in paramter 
.RE
.PP

.SS "int files_management (\fBt_data\fP * data)"

.PP
Executes all the files redirection tests\&. 
.PP
\fBParameters\fP
.RS 4
\fIdata\fP data structure 
.RE
.PP
\fBReturns\fP
.RS 4
int 0 OK, 1 is at least one file redirection is invalid 
.RE
.PP

.SS "int fill_heredocs (\fBt_garbage\fP * garbage, \fBt_command\fP * command)"

.PP
Fill all the heredocs in the correct order\&. 
.PP
\fBParameters\fP
.RS 4
\fIcommand\fP command structure 
.RE
.PP
\fBReturns\fP
.RS 4
int 0 OK, otherwise error 
.RE
.PP

.SS "char * ft_trim_word (char * str)"

.SS "int open_file_with_rights (\fBt_garbage\fP * garbage, \fBt_file\fP * file, t_bool in_out)"

.PP
Open a file with it's rights (permissions) 
.PP
\fBParameters\fP
.RS 4
\fIfile\fP file structure 
.br
\fIin_out\fP 0 = IN, 1 = OUT 
.RE
.PP
\fBReturns\fP
.RS 4
int 
.RE
.PP

.SS "char * read_heredoc (\fBt_tmp\fP * tmp, char * delimitor)"

.PP
Read from stdin and outputs to a file, stops reading when Ctrl+D or when a delimitor is found\&. 
.PP
\fBParameters\fP
.RS 4
\fItmp\fP structure for heredocs 
.br
\fIdelimitor\fP string to know when to stop reading 
.RE
.PP
\fBReturns\fP
.RS 4
char* tmp->name if successful, NULL otherwise 
.RE
.PP

.SS "void read_write_to (\fBt_garbage\fP * garbage, \fBt_command\fP * command, t_bool in_out)"

.PP
Opens the files to read and writes\&. 
.PP
\fBParameters\fP
.RS 4
\fIin_out\fP 0 = IN, 1 = OUT 
.RE
.PP

.SS "\fBt_command\fP * remove_used_file_tokens (\fBt_data\fP * data)"

.PP
Removes all the tokens of file redirections allready used\&. 
.PP
\fBParameters\fP
.RS 4
\fIdata\fP data structure 
.RE
.PP
\fBReturns\fP
.RS 4
t_command* 
.RE
.PP

.SS "\fBt_file\fP * search_last_file (\fBt_file\fP * file, \fBt_file\fP * already_searched)"

.PP
Return the last file that is not already_searched\&. 
.PP
\fBParameters\fP
.RS 4
\fIfile\fP file structure 
.br
\fIalready_searched\fP previous file from search 
.RE
.PP
\fBReturns\fP
.RS 4
t_file* last file begore already_searched 
.RE
.PP

.SS "int verify_access (\fBt_garbage\fP * garbage, \fBt_command\fP * command)"

.PP
Verify that all files are valid if at least one file is invalid, modifies the boolean in command but still return 0\&. 
.PP
\fBParameters\fP
.RS 4
\fIcommand\fP command structure 
.RE
.PP
\fBReturns\fP
.RS 4
int 0 OK, error otherwise 
.RE
.PP

.SH "Author"
.PP 
Generated automatically by Doxygen for Minishell from the source code\&.
